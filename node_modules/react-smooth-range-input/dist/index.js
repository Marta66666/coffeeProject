'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var reactSimpleAnimate = require('react-simple-animate');
var FlipNumbers = _interopDefault(require('react-flip-numbers'));

function debounce(func, wait) {
    let timeout;
    return function () {
        // @ts-ignore
        const context = this;
        const args = arguments;
        const later = function () {
            timeout = null;
            func.apply(context, args);
        };
        const callNow = !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow)
            func.apply(context, args);
    };
}

function findElementXandY(e) {
    const rect = e.target.getBoundingClientRect();
    return { x: e.clientX || e.touches[0].clientX - rect.left, y: e.clientY || e.touches[0].clientY - rect.top };
}

const calculateDragDistance = ({ dragDistance, maxPositionX, totalStepsNumber, min, }) => {
    const result = dragDistance ? dragDistance / (maxPositionX / totalStepsNumber) : 0;
    return Math.ceil(result + min);
};
const calculatePosition = (padding, buttonSize, { width, value, min, totalStepsNumber, }) => {
    const maxPositionX = width - buttonSize - padding * 2;
    const arrowKeyPerClickDistance = maxPositionX / totalStepsNumber;
    const position = (value - min) * arrowKeyPerClickDistance;
    if (position < 0)
        return 0;
    if (position < padding)
        return padding;
    return position > maxPositionX ? maxPositionX : position;
};
function getRangedPositionX({ dragX, maxPositionX, padding, }) {
    if (padding && dragX <= padding) {
        return padding;
    }
    if (dragX <= 0) {
        return 0;
    }
    if (dragX >= maxPositionX) {
        return maxPositionX;
    }
    return dragX;
}
const getMaxScrollDistance = (width, buttonSize, padding) => width - buttonSize - padding;
const getDistancePerMove = (width, numberSteps) => width / numberSteps;
const getTouchPosition = (touchX, left, buttonSize) => touchX - left - buttonSize / 2;
const getMousePosition = (dragX, previousClientX, clientX) => dragX - (previousClientX - clientX);

function createArrayWithNumbers(length) {
    return Array.from({ length }, (_, k) => k + 1);
}

var SliderIndicator = ({ amount, color, isThin, barColor, hasTickMarks }) => (React.createElement("div", { style: Object.assign({ display: 'flex', width: '100%', justifyContent: 'space-around', minHeight: '10px', pointerEvents: 'none' }, (isThin ? { background: barColor, borderRadius: '4px' } : { paddingTop: '15px' })) }, hasTickMarks &&
    createArrayWithNumbers(amount > 50 ? 50 : amount).map(index => (React.createElement("span", { style: {
            height: '10px',
            width: '1px',
            background: color,
        }, key: index })))));

const bubbleWithTail = 'M38.8,19.9C38.8,30.4,19.9,63,19.9,63S1,30.4,1,19.9S9.5,1,19.9,1S38.8,9.5,38.8,19.9z';
const bubble = 'M38.8,43.9c0,10.4-8.5,18.9-18.9,18.9S1,54.4,1,43.9S9.5,24,19.9,24S38.8,33.5,38.8,43.9z';

const commonAnimationProps = {
    easeType: 'cubic-bezier(0.86, 0, 0.07, 1)',
    start: {
        transform: 'translateY(0)',
    },
};
const flipNumberProps = {
    height: 14,
    width: 9,
    color: 'black',
    background: 'white',
    perspective: 370,
    duration: 0.4,
    play: true,
    numberStyle: { outline: '1px solid transparent' },
    disabled: false,
};
var Controller = React.forwardRef(function Controller({ onFocus, onBlur, controllerHeight = 0, controllerWidth = 0, height, dragX, showBubble, isControlByKeyBoard, value, onMouseDown, onInteractEnd, barColor, textBackgroundColor, textColor, isThin, isTouchDevice, disabled, shouldDisplayValue, customController, max, min, shouldAnimateNumber, isFocusing, focusStyle, }, ref) {
    const controllerRootRef = (ref || {}).controllerRootRef;
    const controllerRef = (ref || {}).controllerRef;
    let top = (isThin ? height - controllerHeight : height - controllerHeight) / 2;
    if (customController) {
        top = isThin ? (height - controllerHeight) / 2 : height - controllerHeight;
    }
    return (React.createElement("div", Object.assign({}, {
        onClick: e => {
            if (typeof e.cancelable !== 'boolean' || e.cancelable)
                e.stopPropagation();
        },
        onFocus: onFocus,
        onBlur: onBlur,
    }, (isTouchDevice
        ? {}
        : {
            onMouseDown: onMouseDown,
            onMouseUp: onInteractEnd,
        }), { tabIndex: 0, style: Object.assign({ top: `${top}px`, position: 'absolute', cursor: disabled ? 'not-allowed' : '-webkit-grab', transform: `translateX(${dragX}px)`, transition: isControlByKeyBoard ? '0.15s all ease-in' : '0s all', width: controllerWidth, height: controllerHeight - 10, outline: 'none' }, (isTouchDevice ? { pointerEvents: 'none' } : null)), role: "slider", "aria-valuenow": value, "aria-valuemin": min, "aria-valuemax": max, "aria-valuetext": value.toString(), ref: controllerRootRef }),
        !customController && (React.createElement(reactSimpleAnimate.Animate, Object.assign({ play: showBubble }, commonAnimationProps, { duration: showBubble ? 0.2 : 0.3, start: {
                transform: 'translateY(0)',
            }, end: {
                transform: `translateY(-${isThin ? 32 : 22}px) scale(1.65)`,
            }, easeType: "cubic-bezier(0.86, 0, 0.07, 1)", render: ({ style }) => (React.createElement("svg", { style: Object.assign({ position: 'absolute', top: '-25px', left: 0 }, style), x: "0px", y: "0px", width: `${controllerHeight}px`, height: "64px", viewBox: "0 0 40 64" },
                React.createElement("path", { style: {
                        transition: '0.3s all',
                        fill: barColor,
                    }, d: showBubble ? bubbleWithTail : bubble }))) }))),
        React.createElement(reactSimpleAnimate.Animate, Object.assign({ play: showBubble }, commonAnimationProps, { end: {
                transform: `translateY(-${isThin ? 58 : 48}px) scale(1.3)`,
            }, duration: showBubble ? 0.3 : 0.1, render: ({ style }) => customController ? (customController({
                ref: controllerRef,
                value,
            })) : (React.createElement("div", { style: Object.assign({ background: textBackgroundColor, height: `${controllerHeight}px`, width: `${controllerHeight}px`, borderRadius: '50%', position: 'absolute' }, (isFocusing && !isTouchDevice ? { boxShadow: focusStyle || 'rgb(0, 0, 0) 0px 0px 6px' } : null), style), "aria-hidden": "true" }, shouldDisplayValue && (React.createElement("span", { style: Object.assign({ position: 'absolute', left: 0, width: `${controllerHeight}px`, color: textColor, fontWeight: 600 }, (shouldAnimateNumber
                    ? { top: '10px' }
                    : {
                        top: 0,
                        display: 'flex',
                        justifyContent: 'center',
                        alignItems: 'center',
                        fontSize: '15px',
                        height: `${controllerHeight}px`,
                    })) }, shouldAnimateNumber ? React.createElement(FlipNumbers, Object.assign({}, flipNumberProps, { numbers: value.toString() })) : value)))) }))));
});

var isTouchDevice = () => 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;

function preventScrollOnMobile() {
    let originalOnTouchMove;
    const preventDefault = (e) => e.preventDefault();
    const preventAction = (e) => {
        // @ts-ignore
        if (!this.isTouching)
            return;
        if (e)
            preventDefault(e);
        document.addEventListener('touchmove', preventDefault, { passive: false });
        return false;
    };
    if (!preventAction()) {
        originalOnTouchMove = document.ontouchmove;
    }
    document.ontouchmove = preventAction;
    document.ontouchmove = preventAction; // no joke: only the second one (.ontouchmove) works on mobile safari :)
    return () => {
        document.ontouchmove = originalOnTouchMove;
        document.removeEventListener('touchmove', preventDefault);
    };
}

var colors = {
    white: '#fff',
    lightBlue: '#3562cd',
    blue: '#244BA8',
};

const delayMsForAnimation = 200;
class Slider extends React.PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            dragX: 0,
            showBubble: false,
            isFocusing: false,
        };
        this.isControlByKeyBoard = false;
        this.wrapperRef = React.createRef();
        this.controllerRootRef = React.createRef();
        this.touchDevice = isTouchDevice();
        this.controllerRef = React.createRef();
        this.maxScrollDistance = 0;
        this.arrowKeyPerClickDistance = 0;
        this.controllerHeight = this.props.controllerHeight || 0;
        this.controllerWidth = this.props.controllerWidth || 0;
        this.clientX = 0;
        this.value = 0;
        this.isTouching = false;
        this.totalStepsNumber = this.props.max - this.props.min;
        this.calculatePositionWithOffset = calculatePosition.bind(null, this.props.padding, this.controllerHeight);
        this.restoreTouchMove = () => { };
        this.onResize = debounce(() => {
            if (!this.wrapperRef.current)
                return;
            const { width } = this.wrapperRef.current.getBoundingClientRect();
            const { min, padding } = this.props;
            this.maxScrollDistance = getMaxScrollDistance(width, this.controllerWidth, padding);
            this.arrowKeyPerClickDistance = getDistancePerMove(this.maxScrollDistance, this.totalStepsNumber);
            this.setState({
                dragX: this.calculatePositionWithOffset({
                    width,
                    value: this.value,
                    min,
                    totalStepsNumber: this.totalStepsNumber,
                }),
            });
        }, 1000);
        this.commonOnStart = (e) => {
            e.stopPropagation();
            this.isControlByKeyBoard = false;
            this.setState({
                showBubble: true,
            });
        };
        this.onTouchStart = (e) => {
            const { padding, disabled } = this.props;
            if (disabled)
                return;
            this.isTouching = true;
            this.restoreTouchMove = preventScrollOnMobile.call(this);
            const { left } = this.wrapperRef.current.getBoundingClientRect();
            this.commonOnStart(e);
            this.setState({
                dragX: getRangedPositionX({
                    padding,
                    dragX: getTouchPosition(e.targetTouches[0].pageX, left, this.controllerWidth),
                    maxPositionX: this.maxScrollDistance,
                }),
            });
            document.addEventListener('touchend', this.onInteractEnd);
        };
        this.onMouseDown = (e) => {
            if (this.touchDevice)
                return;
            if (this.props.disabled)
                return;
            document.addEventListener('mousemove', this.onMouseMove);
            document.addEventListener('mouseup', this.onInteractEnd);
            this.commonOnStart(e);
            this.clientX = e.clientX;
        };
        this.onInteractEnd = (e) => {
            e.stopPropagation();
            this.isTouching = false;
            this.setState({
                showBubble: false,
            });
            document.removeEventListener('touchend', this.onInteractEnd);
            document.removeEventListener('mousemove', this.onMouseMove);
            document.removeEventListener('mouseup', this.onInteractEnd);
            this.restoreTouchMove();
            this.calculateValueAndUpdateStore();
        };
        this.onTouchMove = (e) => {
            e.stopPropagation();
            const { left } = this.wrapperRef.current.getBoundingClientRect();
            const { padding, disabled } = this.props;
            if (disabled)
                return;
            this.setState({
                dragX: getRangedPositionX({
                    padding,
                    dragX: getTouchPosition(e.targetTouches[0].pageX, left, this.controllerWidth),
                    maxPositionX: this.maxScrollDistance,
                }),
            });
        };
        this.onMouseMove = (e) => {
            e.stopPropagation();
            const { dragX } = this.state;
            const { padding, disabled } = this.props;
            if (disabled)
                return;
            this.setState({
                dragX: getRangedPositionX({
                    padding,
                    dragX: getMousePosition(dragX, this.clientX, e.clientX),
                    maxPositionX: this.maxScrollDistance,
                }),
            });
            this.clientX = e.clientX;
        };
        this.onFocus = () => {
            this.setState({
                isFocusing: true,
            });
            document.addEventListener('keydown', this.onKeyEvent);
        };
        this.onBlur = () => {
            this.setState({
                isFocusing: false,
            });
            document.removeEventListener('keydown', this.onKeyEvent);
        };
        this.onClick = (e) => {
            const { padding, disabled } = this.props;
            if (disabled)
                return;
            const { left } = e.target.getBoundingClientRect();
            const { x } = findElementXandY(e);
            this.isControlByKeyBoard = true;
            clearTimeout(this.timer);
            this.setState({
                dragX: getRangedPositionX({
                    padding,
                    dragX: getTouchPosition(x, left, this.controllerWidth),
                    maxPositionX: this.maxScrollDistance,
                }),
            });
            this.timer = setTimeout(() => {
                this.calculateValueAndUpdateStore();
            }, delayMsForAnimation);
            this.controllerRootRef.current.focus();
        };
        this.onKeyEvent = (e) => {
            this.isControlByKeyBoard = true;
            const { dragX } = this.state;
            const { padding, disabled } = this.props;
            if (disabled || !['ArrowDown', 'ArrowLeft', 'ArrowUp', 'ArrowRight'].includes(e.key))
                return;
            e.preventDefault();
            const isPressedLeft = ['ArrowUp', 'ArrowRight'].includes(e.key);
            this.setState({
                dragX: getRangedPositionX({
                    padding,
                    dragX: isPressedLeft ? dragX + this.arrowKeyPerClickDistance : dragX - this.arrowKeyPerClickDistance,
                    maxPositionX: this.maxScrollDistance,
                }),
            });
            this.calculateValueAndUpdateStore();
        };
    }
    componentDidMount() {
        const { width } = this.wrapperRef.current.getBoundingClientRect();
        const { value, min, padding = 0 } = this.props;
        if (this.controllerRef && this.controllerRef.current) {
            const { width: controllerWidth, height: controllerHeight } = this.controllerRef.current.getBoundingClientRect();
            this.controllerWidth = controllerWidth;
            this.controllerHeight = controllerHeight;
        }
        this.maxScrollDistance = getMaxScrollDistance(width, this.controllerWidth, padding);
        this.arrowKeyPerClickDistance = getDistancePerMove(this.maxScrollDistance, this.totalStepsNumber);
        this.restoreTouchMove = preventScrollOnMobile.call(this);
        window.addEventListener('resize', this.onResize);
        this.setState({
            dragX: this.calculatePositionWithOffset({
                width,
                value: value,
                min,
                totalStepsNumber: this.totalStepsNumber,
            }),
        });
    }
    componentWillUnmount() {
        document.removeEventListener('keydown', this.onKeyEvent);
        document.removeEventListener('mouseup', this.onInteractEnd);
        document.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('resize', this.onResize);
        clearTimeout(this.timer);
        this.restoreTouchMove();
    }
    calculateValueAndUpdateStore(shouldTriggerOnChange = true) {
        const { min, onChange, padding = 0 } = this.props;
        const { dragX } = this.state;
        this.value = calculateDragDistance({
            dragDistance: dragX - padding,
            maxPositionX: this.maxScrollDistance,
            totalStepsNumber: this.totalStepsNumber,
            min,
        });
        if (shouldTriggerOnChange && onChange) {
            onChange(this.value);
        }
    }
    render() {
        const { dragX, showBubble, isFocusing } = this.state;
        const { hasTickMarks, textBackgroundColor, barColor, textColor, tickColor, disabled, shouldAnimateOnTouch, shouldDisplayValue, customController, max, min, barHeight = 0, barStyle = {}, shouldAnimateNumber, focusStyle, } = this.props;
        const isThin = barHeight < this.controllerHeight;
        this.calculateValueAndUpdateStore(false);
        return (React.createElement("div", Object.assign({ style: Object.assign({ height: `${barHeight}px`, width: '100%', borderRadius: '4px', background: barColor }, (isThin ? { marginTop: `${this.controllerHeight - barHeight}px` } : {}), { position: 'relative', MozUserSelect: 'none', WebkitUserSelect: 'none', msUserSelect: 'none', userSelect: 'none' }, (disabled ? { opacity: 0.5, cursor: 'not-allowed' } : { cursor: 'pointer' }), barStyle) }, (this.touchDevice
            ? {
                onTouchStart: this.onTouchStart,
                onTouchMove: this.onTouchMove,
            }
            : {}), { onClick: this.onClick, ref: this.wrapperRef }),
            React.createElement(Controller, { isTouchDevice: this.touchDevice, focusStyle: focusStyle, onFocus: this.onFocus, onBlur: this.onBlur, height: barHeight, isFocusing: isFocusing, controllerWidth: this.controllerWidth, controllerHeight: this.controllerHeight, dragX: dragX, showBubble: showBubble && !!shouldAnimateOnTouch, shouldAnimateNumber: shouldAnimateNumber, isControlByKeyBoard: this.isControlByKeyBoard, value: this.value, shouldDisplayValue: shouldDisplayValue, onMouseDown: this.onMouseDown, onInteractEnd: this.onInteractEnd, barColor: barColor, textBackgroundColor: textBackgroundColor, textColor: textColor, isThin: isThin, disabled: disabled, customController: customController, ref: {
                    // @ts-ignore: Unreachable code error
                    controllerRootRef: this.controllerRootRef,
                    controllerRef: this.controllerRef,
                }, max: max, min: min }),
            (hasTickMarks || isThin) && (React.createElement(SliderIndicator, { barColor: barColor, color: tickColor, amount: this.totalStepsNumber, isThin: isThin, hasTickMarks: hasTickMarks }))));
    }
}
Slider.defaultProps = {
    value: 0,
    onChange: () => { },
    barColor: colors.blue,
    textColor: colors.blue,
    textBackgroundColor: colors.white,
    tickColor: colors.lightBlue,
    disabled: false,
    padding: 3,
    hasTickMarks: true,
    shouldAnimateOnTouch: true,
    shouldDisplayValue: true,
    shouldAnimateNumber: true,
    customController: null,
    controllerWidth: 34,
    controllerHeight: 34,
    barHeight: 40,
    barStyle: {},
};

module.exports = Slider;
